<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>CourseKeyPointsOfDIP</title><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }







 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><p>参考书籍：&lt;数字图像处理-冈萨雷斯&gt;</p><p>这里所列内容仅是大纲，有些符号并未说明其物理意义，有疑惑时请借助书本来理解</p><p>目前只包含要考试的内容，后续将会加上其他部分的内容</p><p><span class='math-in-toc'>\spadesuit</span>标记的地方为重点内容</p><p>消除噪声的空间滤波部分、共生矩阵描绘子部分公式太多，暂时没有写上去</p><hr /><p>&nbsp;</p><ul><li><p><strong>一、数字图像处理基础</strong></p><ul><li><p>图像形成模型</p><ul><li>入射分量，反射分量（透射系数）<span class='math-in-toc'>f(x,y) = i(x,y)r(x,y)</span> （取值范围）</li></ul></li><li><p>取样与量化</p><ul><li><p>取样，量化，灰度级，动态范围，对比度，空间分辨率（2044 dpi），灰度分辨率</p></li><li><p>内插 <span class='math-in-toc'>\spadesuit</span></p><ul><li>最近邻内插</li><li>双线性内插 <span class='math-in-toc'>v(x,y) = ax+by+cxy+d</span></li><li>双三次内插 <span class='math-in-toc'>v(x,y)= \sum_{i=1}^3\sum_{j=0}^3a_{ij}x^iy^j</span> </li><li>样条，小波</li></ul></li></ul></li><li><p>像素间的关系</p><ul><li>邻接性（4,8,m），连通性（连通分量，连通集），区域（邻接区域，前景，背景），边界（内边界，外边界-闭合通路）</li><li>距离度量：欧式距离，城市街区距离，棋盘距离</li></ul></li><li><p>数学工具</p><ul><li><p>阵列与矩阵操作：阵列操作（默认）与矩阵操作</p><ul><li>平均-降噪（空间上与时间上）</li><li>相减-增强差别</li><li>相除/相乘-校正阴影</li></ul></li><li><p>线性与非线性操作</p></li><li><p>集合与逻辑操作</p></li><li><p>空间操作</p><ul><li><p>单像素操作 <span class='math-in-toc'>s=T(z)</span></p></li><li><p>领域操作 <span class='math-in-toc'>S_{xy}</span></p></li><li><p>空间变换 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>仿射变换 <span class='math-in-toc'>(x,y)=T{(v,w)}</span> T为3x3矩阵</p><ul><li>前向映射</li><li>反向映射（常用）</li></ul></li><li><p>图像配准 <span class='math-in-toc'>x=a_1v+b_1w+c_1vw+d_1</span> <span class='math-in-toc'>y=a_2v+b_2w+c_2vw+d_2</span></p></li></ul></li></ul></li><li><p>向量与矩阵操作</p></li><li><p>图像变换：时域-频域</p></li><li><p>概率方法</p></li></ul></li></ul></li><li><p><strong>二、灰度变换与空间滤波</strong></p><ul><li><p>灰度变换函数</p><ul><li><p>图像反转 <span class='math-in-toc'>s=L-1-r</span></p></li><li><p>对数变换 <span class='math-in-toc'>s=clog(1+r)</span> <span class='math-in-toc'>c=const,r\geq0</span> </p><ul><li>扩展低灰度级的值，压缩高灰度级的值</li><li>标定傅里叶频谱图像</li></ul></li><li><p>幂律（伽马）变换 <span class='math-in-toc'>s=cr^\gamma</span> <span class='math-in-toc'>c,\gamma=const&gt;0</span></p><ul><li>既可以扩展暗值（处理整体偏暗的图像）也可以扩展亮值（处理整体偏亮的图像）</li><li>伽马校正：图像获取、打印和显示的各种设备根据幂律产生响应 <span class='math-in-toc'>\gamma_2=\frac{1}{\gamma_1}</span></li></ul></li><li><p>分段线性变换函数</p><ul><li>对比度拉伸-&gt;阈值处理函数（二值图像）</li><li>灰度级分层</li><li>比特平面分层</li></ul></li></ul></li><li><p>直方图处理 </p><ul><li><p>PDF-概率密度函数<span>	</span>CDF-累积分布函数</p></li><li><p>直方图均衡 <span class='math-in-toc'>s=T(r)\ \ 0\leq{r}\leq{L-1}</span>  所谓均衡：<span class='math-in-toc'>p_r(s)=\frac{1}{L-1},\  {0}\leq{s}\leq{L-1}</span> (<span class='math-in-toc'>p_r(s)=p_r(r)|\frac{dr}{ds}|</span>) <span class='math-in-toc'>\spadesuit</span></p><ul><li>连续：<span class='math-in-toc'>s=T(r)=(L-1)\int_{0}^{r}p_r(w)dw</span></li><li>离散：<span class='math-in-toc'>s_k=T(r_k)=(L-1)\sum_{j=0}^{k}p_r(r_j)=\frac{L-1}{MN}\sum_{j=0}^kn_j</span> 再取整</li><li>自适应对比度增强</li></ul></li><li><p>直方图匹配（规定化）<span class='math-in-toc'>\spadesuit</span></p><ul><li><p>查表法</p></li><li><p>过程</p><ul><li>对输入图像计算直方图均衡变换并取整（四舍五入）<span>	</span>r-&gt;s的映射</li><li>对给定直方图计算均衡变换并取整（四舍五入）并存到一个表中   z-&gt;s的映射</li><li>将上述两个映射合并（当s-&gt;z映射不唯一时取最小，没有时取最近）   r-&gt;s的映射</li></ul></li><li><p>直方图规定化在大多数时候都是试凑的过程，对任何一个给定的增强任务都必须借助于实际分析来确定直方图的规则</p></li></ul></li><li><p>局部直方图处理</p><ul><li>在 <span class='math-in-toc'>S_{xy}</span> 邻域中进行直方图均衡或规定化</li><li>消除棋盘效应</li></ul></li><li><p>在图像增强中使用直方图统计</p><ul><li><span class='math-in-toc'>r</span> 关于其均值的 <span class='math-in-toc'>n</span> 阶矩定义：  <span class='math-in-toc'>\mu_n(r)=\sum_{i=0}^{L-1}(r_i-m)^np(r_i)</span>   <span class='math-in-toc'>m=\sum_{i=0}^{L-1}r_ip(r_i)</span></li><li>取样均值：<span class='math-in-toc'>m=\frac{1}{MN}\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)</span>   取样方差：<span class='math-in-toc'>\sigma^2=\frac{1}{MN}\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}(f(x,y)-m)^2</span></li><li><span class='math-in-toc'>S_{xy}</span> 可以定义局部均值和局部方差 -&gt; 局部增强 </li></ul></li></ul></li><li><p>空间滤波</p><ul><li><p>基础</p><ul><li><p>相关与卷积</p></li><li><p>滤波器模板</p><ul><li>高斯函数<span>	</span><span class='math-in-toc'>h(x,y)=e^{-\frac{x^2+y^2}{2\sigma^2}}</span></li><li>常用0填充边界</li></ul></li></ul></li><li><p>平滑空间滤波器 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>线性滤波器</p><ul><li>盒状滤波器与非盒状滤波器</li><li><span class='math-in-toc'>g(x,y)=\frac{\sum_{s=-a}^a\sum_{t=-b}^bw(s,t)f(x+s,y+t)}{\sum_{s=-a}^a\sum_{t=-b}^bw(s,t)}</span></li></ul></li><li><p>非线性(统计排序)滤波器</p><ul><li>最大/小值滤波器，中值滤波器（椒盐噪声）</li></ul></li></ul></li><li><p>锐化空间滤波器 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>基础</p><ul><li>一阶微分：<span class='math-in-toc'>\frac{\partial f}{\partial x}=f(x+1)-f(x)</span></li><li>二阶微分：<span class='math-in-toc'>\frac{\partial^2 f}{\partial x^2}=f(x+1)+f(x-1)-2f(x)</span></li><li>二阶微分在增强细节方面比一阶微分好得多</li></ul></li><li><p>拉普拉斯算子</p><ul><li><p><span class='math-in-toc'>\nabla^2 f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)</span> </p></li><li><p>滤波器模板</p><p><span>	</span><span class='math-in-toc'>\left[\begin{matrix}0&amp;1&amp;0\\1&amp;-4&amp;1\\0&amp;1&amp;0\\\end{matrix}\right] </span><span class='math-in-toc'>\left[\begin{matrix}1 &amp; 1 &amp; 1 \\ 1&amp; -8 &amp; 1 \\1 &amp; 1 &amp; 1\end{matrix}\right] </span>  <span class='math-in-toc'>\left[\begin{matrix}0&amp;-1&amp;0\\-1&amp;4&amp;-1\\0&amp;-1&amp;0\\\end{matrix}\right]</span><span class='math-in-toc'>\left[\begin{matrix}-1&amp;-1&amp;-1 \\-1&amp;8&amp;-1\\-1&amp;-1&amp;-1\end{matrix}\right]</span> </p></li><li><p><span class='math-in-toc'>g(x,y)=f(x,y)+c(\nabla^2f(x,y))\  c=-1/1</span></p></li><li><p>拉普拉斯滤波后的图像的标定</p></li></ul></li><li><p>非锐化掩蔽与高提升滤波</p><ul><li><span class='math-in-toc'>g(x,y)=f(x,y)+k*g_{mask}(x,y)=f(x,y)+k*(f(x,y)-\overline{f}(x,y))</span></li><li>k=1---非锐化掩蔽<span>	</span>k&gt;1---高提升滤波          k过大将产生不好的结果</li></ul></li><li><p>梯度（一阶微分）</p><ul><li><span class='math-in-toc'>M(x,y)=mag(\nabla f)=\sqrt{g_x^2+g_y^2}\approx|g_x|+|g_y|</span> 没有各向同性</li><li>Roberts算子</li><li>Sobel算子：中心系数使用权重2是通过突出中心点的作用达到平滑的目的</li><li>模板的系数之和为0以保证在灰度恒定区域响应为0</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>三、频率域滤波</strong></p><ul><li><p>基础</p><ul><li><p>单变量</p><ul><li>连续：<span class='math-in-toc'>F(\mu)=\int_{-\infty}^\infty f(t)e^{-j2\pi\mu t}dt</span>, <span class='math-in-toc'>f(t)=\int_{-\infty}^\infty F(\mu)e^{j2\pi\mu t}d\mu</span>    <span>	</span><span class='math-in-toc'>w=2\pi\mu</span></li><li>离散：<span class='math-in-toc'>F(u)=\sum_{x=0}^{M-1}f(x)e^{-j2\pi ux/M}</span> , <span class='math-in-toc'>f(x)=\frac{1}{M}\sum_{u=0}^{M-1}F(u)e^{j2\pi ux/M}</span> </li></ul></li><li><p>二维变量 <span class='math-in-toc'>\spadesuit</span></p><ul><li>连续：<span class='math-in-toc'>F(\mu,v)=\int_{-\infty}^\infty\int_{-\infty}^\infty f(t,z)e^{-j2\pi(\mu t+vz)}dtdz</span>, <span class='math-in-toc'>f(t)=\int_{-\infty}^\infty \int_{-\infty}^\infty F(\mu,v)e^{j2\pi(\mu t+vz)}d\mu dv</span>  </li><li>离散：<span class='math-in-toc'>F(u,v)=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi (ux/M+vy/N)}</span> , <span class='math-in-toc'>f(x,y)=\frac{1}{MN}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}F(u,v)e^{j2\pi (ux/M+vy/N)}</span></li></ul></li><li><p>空间混淆与时间混淆，过取样与欠取样，莫尔（波纹）模式</p></li><li><p>二维离散傅里叶变换的性质 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p><span class='math-in-toc'>f(x,y)(-1)^{(x+y)}\Leftrightarrow F(u-M/2,v-N/2)</span></p></li><li><p><span class='math-in-toc'>F(u,v)=|F(u,v)|e^{j\phi (u,v)}</span>        其中：</p><ul><li><span class='math-in-toc'>|F(u,v)|</span> 表示傅里叶谱（频谱），<span class='math-in-toc'>\phi (u,v)=arctan\frac{I}{R}</span> 表示相角</li><li><span class='math-in-toc'>P(u,v)=|F(u,v)|^2</span> 表示功率谱，<span class='math-in-toc'>|F(0,0)|=MN|\overline{f}(x,y)|</span> 称为直流(dc)分量------对数变换以标定 <span class='math-in-toc'>1+log|F(u,v)|</span></li><li>谱对图像的平移不敏感，随图像旋转而以相同的角度旋转</li></ul></li><li><p>卷积</p><ul><li><p><span class='math-in-toc'>f(x,y)\star h(x,y)=\sum_{m=0}^{M-1}\sum_{n=0}^{N-1}f(m,n)h(x-m,y-n)</span>（周期卷积，区别于循环卷积）</p></li><li><p>周期的靠近导致缠绕错误-----零填充</p><ul><li><span class='math-in-toc'>P\geq A+C-1</span> , <span class='math-in-toc'>Q\geq B+D-1</span> </li><li>P，Q最好选择满足上述条件的最小偶整数</li></ul></li></ul></li></ul></li></ul></li><li><p>空间滤波与频域滤波的关系</p><ul><li>高斯函数（互易性）</li><li>在频率域通过实验选择了一个特定的滤波器，它的实际实现常常实在空间域完成的</li></ul></li><li><p>频率域滤波基础</p><ul><li><p>振铃现象：任何实现0填充的滤波器的空间截断将引入不连续性，通常在频域表现为振铃现象</p></li><li><p>步骤 <span class='math-in-toc'>\spadesuit</span></p><ul><li>给定<span class='math-in-toc'>M\times N</span>输入图像<span class='math-in-toc'>f(x,y)</span> ，选择<span class='math-in-toc'>P=2M,Q=2N</span></li><li>零填充得到<span class='math-in-toc'>f_p(x,y)</span></li><li><span class='math-in-toc'>F(u,v)=\Im ((-1)^{x+y}f_p(x,y)) </span></li><li><span class='math-in-toc'>G(u,v)=H(u,v)F(u,v)</span>, <span class='math-in-toc'>H(u,v)</span> 大小为<span class='math-in-toc'>P\times Q</span>, 中心在<span class='math-in-toc'>(P/2,Q/2)</span> 处的实对称滤波函数</li><li><span class='math-in-toc'>g_p(x,y)=(real(\Im^{-1}(G(u,v))))(-1)^{x+y}</span> 取实部是为了忽略计算不准确导致的寄生复分量</li><li>从<span class='math-in-toc'>g_p(x,y)</span> 的左上象限提取<span class='math-in-toc'>M\times N</span> 区域得到最终结果<span class='math-in-toc'>g(x,y)</span></li></ul></li></ul></li><li><p>平滑图像 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>理想低通滤波器（ILPF）</p><ul><li><span class='math-in-toc'>H(u,v)=\begin{cases}1, &amp; D(u,v)\leq D_0 \\ 0, &amp; D(u,v)&gt;D_0 \end{cases}</span></li><li>计算功率谱比</li><li>有振铃，截止频率半径越大，越不明显</li></ul></li><li><p>布特沃斯低通滤波器（BLPF）</p><ul><li><span class='math-in-toc'>H(u,v)=\frac{1}{1+(D(u,v)/D_0)^{2n}}</span> </li><li>一阶没有可见的振铃现象，二阶很难察觉，更高阶会很明显</li></ul></li><li><p>高斯低通滤波器（GLPF）</p><ul><li><span class='math-in-toc'>H(u,v)=e^{-\frac{D^2(u,v)}{2D_0^2}}</span></li><li>没有振铃，适用于医学成像等任何人工缺陷都不可接受的情况</li></ul></li><li><p><span class='math-in-toc'>sinc</span>函数的中心波瓣是引起模糊的主因，外侧较小的波瓣是造成振铃的主因(ILPF:函数展开度与半径成反比，半径越大，越趋近于冲激)</p></li></ul></li><li><p>锐化图像 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>IHPF</p></li><li><p>BHPF</p></li><li><p>GHPF</p></li><li><p>拉普拉斯算子</p><ul><li><span class='math-in-toc'>H(u,v)=-4\pi^2D^2(u,v)</span></li><li><span class='math-in-toc'>g(x,y)=f(x,y)+c\nabla^2f(x,y)\quad c=-1</span></li><li>标定</li></ul></li><li><p>高频强调滤波</p><ul><li><span class='math-in-toc'>g(x,y)=\Im^{-1}((k_1+k_2*H_{HP}(u,v))F(u,v))\quad k_1\geq0\quad k_2\geq0</span></li></ul></li><li><p>同态滤波</p><ul><li><span class='math-in-toc'>H(u,v)=(\gamma_H-\gamma_L)(1-e^{c(D^2(u,v)/D_0^2)})+\gamma_L\quad \gamma_L&lt;c=const&lt;\gamma_H\mbox{控制函数坡度的锐利度}</span></li><li>照射分量-缓慢的空间变化（低频）；反射分量-突变（高频）</li></ul></li></ul></li></ul></li><li><p><strong>四、图像复原与重建</strong></p><ul><li><p>图像退化/复原过程的模型</p><ul><li>目的：获得原始图像的一个估计<span class='math-in-toc'>\hat f(x,y)</span></li><li>退化模型：<span class='math-in-toc'>G(u,v)=H(u,v)F(u,v)+N(u,v)</span></li><li>复原模型：<span class='math-in-toc'>g(x,y)\rightarrow \hat f(x,y)</span></li></ul></li><li><p>噪声模型</p><ul><li><p>各种噪声</p><ul><li>白噪声：傅里叶谱为常量</li><li>高斯噪声  <span class='math-in-toc'>p(z)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(z-\overline z)^2}{2\sigma^2}}</span></li><li>瑞利噪声</li><li>爱尔兰（伽马）噪声  </li><li>指数噪声  <span class='math-in-toc'>p(z)=\begin{cases}ae^{-az},&amp;z\geq0\\0&amp;z&lt;0\end{cases}</span>  均值<span class='math-in-toc'>\overline z=\frac{1}{a}</span> ，方差<span class='math-in-toc'>\sigma^2=\frac{1}{a^2}</span></li><li>均匀噪声  <span class='math-in-toc'>p(z)=\begin{cases}\frac{1}{b-a},&amp;a\leq z\leq b\\0,&amp;\mbox{其他}\end{cases}</span>  均值<span class='math-in-toc'>\overline z=\frac{a+b}{2}</span> ，方差<span class='math-in-toc'>\sigma^2=\frac{(b-a)^2}{12}</span></li><li>脉冲（椒盐）噪声  <span class='math-in-toc'>p(z)=\begin{cases}P_a&amp;z=a\\P_b&amp;z=b\\1-P_a-P_b&amp;\mbox{其他}\end{cases}</span></li></ul></li><li><p>周期噪声---可以通过频率域滤波显著减少</p></li><li><p>噪声参数的估计</p></li></ul></li><li><p>消除噪声---空间滤波 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>均值滤波器</p><ul><li>算术均值滤波器：高斯噪声，均匀噪声</li><li>几何均值滤波器：高斯噪声，均匀噪声（更好）</li><li>谐波均值滤波器：盐粒噪声</li><li>逆谐波均值滤波器：脉冲噪声（正-胡椒噪声，负-盐粒噪声）</li></ul></li><li><p>统计排序滤波器</p><ul><li>中值滤波器：椒盐噪声</li><li>最值滤波器</li><li>中点滤波器：高斯噪声，均匀噪声</li><li>修正的阿尔法均值滤波器：多种噪声混合（如高斯+椒盐）</li></ul></li><li><p>自适应滤波器</p><ul><li>自适应局部降低噪声滤波器</li><li>自适应中值滤波器</li></ul></li></ul></li><li><p>频率域消除周期噪声</p></li><li><p>线性、位置不变的退化（前提假设） <span class='math-in-toc'>\spadesuit</span></p><ul><li>线性=加性+均匀性（齐次性+叠加性）</li><li>位置不变：<span class='math-in-toc'>H(f(x-\alpha,y-\beta))=g(x-\alpha,y-\beta)</span>  图像中任意一点的响应只取决于该点处的输入值，而与其位置无关</li><li>许多类型的退化可以近似为线性、位置不变的过程</li></ul></li><li><p>估计退化函数</p><ul><li><p>观察法</p><ul><li>寻找一个有很强信号内容的区域（如高对比度区域）</li><li>处理该区域得到尽可能不模糊的结果</li><li>得到退化函数</li></ul></li><li><p>实验法</p><ul><li>与获取退化的图像的设备的相似的装置</li><li>用一个亮点模拟冲激</li><li>利用退化模型得到退化函数</li></ul></li><li><p>数学建模法 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>大气湍流模型 <span class='math-in-toc'>H(u,v)=e^{-k(u^2+v^2)^{5/6}}</span>  具体使用时注意要进行平移使函数居中:<span class='math-in-toc'>H(u,v)=e^{-k((u-M/2)^2+(v-N/2)^2)^{5/6}}</span></p></li><li><p>均匀线性运动模糊（从基本原理开始推导）</p><ul><li><span class='math-in-toc'>g(x,y)=\int_0^Tf(x-x_0(t),y-y_0(t))dt</span></li><li><span class='math-in-toc'>G(u,v)=F(x,y)\int_0^Te^{-j2\pi(ux_0(t)+vy_0(t))}dt=F(u,v)H(u,v)</span> </li><li><span class='math-in-toc'>H(u,v)=\frac{T}{\pi(ua+vb)}sin(\pi(ua+vb))e^{-j\pi(ua+vb)}</span></li></ul></li></ul></li></ul></li><li><p>逆滤波 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p><span class='math-in-toc'>\hat F(u,v)=\frac{G(u,v)}{H(u,v)}=F(u,v)+\frac{N(u,v)}{H(u,v)}</span></p><ul><li><span class='math-in-toc'>N(u,v)</span>未知</li><li>当退化函数趋近于0时，<span class='math-in-toc'>N(u,v)/H(u,v)</span>将支配估计值---限制滤波频率使其接近原点</li></ul></li></ul></li><li><p>最小均方误差滤波（维纳滤波） <span class='math-in-toc'>\spadesuit</span></p><ul><li><p><span class='math-in-toc'>min\quad e^2=E((f-\hat f)^2)</span></p></li><li><p>非因果解的推导1</p><ul><li>正交定理：<span class='math-in-toc'>E(eg^*)=0</span></li><li>相关：<span class='math-in-toc'>E(X(k)X^*(l))=r_X(k-l)</span></li><li>卷积与相关</li><li><span class='math-in-toc'>h(x,y)\Rightarrow H(w_1,w_2)\qquad h^*(-x,-y)\Rightarrow H^*(w_1,w_2)</span></li><li><span class='math-in-toc'>W(w_1,w_1)=\frac{H^*(w_1,w_1)}{||H(w_1,w_2)||^2+\frac{P_\eta(w_1,w_2)}{P_f(w_1,w_2)}}</span></li></ul></li><li><p>推导2</p><ul><li><span class='math-in-toc'>E((f-\hat f)(f-\hat f)^*)\Leftrightarrow E((F-\hat F)(F-\hat F)^*)=E((F-W(HF+V))(F-W(FF+V))^*)</span></li><li><span class='math-in-toc'>\partial J/\partial W=0\Rightarrow W(w_1,w_2)=\frac{H^*(w_1,w_2)S_f(w_1,w_2)}{||H(w_1,w_2)||^2S_f(w_1,w_2)+S_\eta(w_1,w_2)}</span></li></ul></li><li><p>最终形式为：<span class='math-in-toc'>W(u,v)=\frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+S_\eta(u,v)/S_f(u,v)}=\frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+K}</span></p></li><li><p><span class='math-in-toc'>SNR\mbox{(信噪比)}=\frac{\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}\hat{f}(x,y)^2}{\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}(f(x,y)-\hat{f}(x,y))^2}</span> (也称均方根信噪比，均方根误差)</p></li><li><p>缺点：未退化图像和噪声的功率谱必须是已知的，用<span class='math-in-toc'>K</span>来估计并不总是一个合适的解</p></li></ul></li><li><p>约束最小二乘滤波 ：核心是解决<span class='math-in-toc'>H</span>对噪声的敏感性问题---以平滑度量的最佳复原 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p><span class='math-in-toc'>min\quad C=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}(\nabla^2f(x,y))^2\qquad s.t.||g-H\hat f||^2=||\eta||^2</span></p></li><li><p>求解</p><ul><li>帕斯瓦定理：<span class='math-in-toc'>\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}|f(x,y)|^2=\frac{1}{MN}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}|F(u,v)|^2</span></li><li>拉格朗日乘子法</li><li><span class='math-in-toc'>\hat F(u,v)=\frac {H^*(u,v)}{|H(u,v)|^2+\gamma |P(u,v)|^2}G(u,v)</span></li><li>其中：<span class='math-in-toc'>P(u,v)</span>是拉普拉斯算子（空间滤波器模板）的傅里叶变换（零填充以使大小一致）</li></ul></li><li><p>算法</p><ul><li><span class='math-in-toc'>\gamma</span>初始化</li><li>计算<span class='math-in-toc'>||r||^2=||g-H\hat f||^2</span></li><li>若<span class='math-in-toc'>||\eta||^2-a\leq||r||^2\leq||\eta||^2+a</span>，则停止；若<span class='math-in-toc'>||r||^2&lt;||\eta||^2-a</span>则增大<span class='math-in-toc'>\gamma</span>；若<span class='math-in-toc'>||r||^2&gt;||\eta||^2+a</span>则减小<span class='math-in-toc'>\gamma</span>。回到上一步</li></ul></li><li><p><span class='math-in-toc'>||\eta||^2=MN(\sigma^2+m_\eta^2)</span></p></li></ul></li></ul></li><li><p><strong>五、图像压缩</strong></p><ul><li><p>基础知识</p><ul><li><p>相对数据冗余<span class='math-in-toc'>R=1-1/C\qquad C=b/b&#39;</span></p></li><li><p>三种主要冗余</p><ul><li><p>编码冗余</p><ul><li>表示每个像素所需的平均比特数<span class='math-in-toc'>L_{avg}=\sum_{k=0}^{L-1}l(r_k)p_r(r_k)</span></li></ul></li><li><p>空间冗余和时间冗余</p></li><li><p>不相关信息</p></li></ul></li><li><p>图像信息的度量 <span class='math-in-toc'>\spadesuit</span></p><ul><li>信源的熵<span class='math-in-toc'>H=-\sum_{j=1}^JP(a_j)logP(a_j)</span></li><li>对于一图像，表示每个像素所需的平均比特数不少于<span class='math-in-toc'>\hat H=-\sum_{k=0}^{L-1}P_r(r_k)log_2P_r(r_k)\quad\mbox{比特/像素}</span></li></ul></li></ul></li><li><p>一些基本的压缩方法 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>霍夫曼编码</p><ul><li><p>步骤：</p><ul><li>对符号按概率排序，依次将具有最小概率的符号合并，生成一个简化信源序列</li><li>编码</li></ul></li><li><p>瞬时的、唯一可解的块编码</p></li><li><p>对于<span class='math-in-toc'>J</span>个信源符号---<span class='math-in-toc'>J</span>个符号概率，<span class='math-in-toc'>J-2</span>次信源简化，<span class='math-in-toc'>J-2</span>次编码赋值------默认的霍夫曼编码表</p></li></ul></li><li><p>算术编码</p><ul><li>步骤</li><li>当被编码的序列的长度增加时，得到的算术编码接近山农第一定理所设定的界限，但由于消息结束指示符的必要性和算法的精度限制，这并不能达到</li></ul></li></ul></li></ul></li><li><p><strong>六、形态学图像处理</strong></p><ul><li><p>基础</p><ul><li>集合的反射<span class='math-in-toc'>\hat A</span>与平移，补集<span class='math-in-toc'>A^c</span></li><li>结构元，将结构元转换为矩形阵列</li></ul></li><li><p>腐蚀和膨胀 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>腐蚀</p><ul><li><span class='math-in-toc'>A\ominus B=\left\{z|(B)_z\subseteq A\right\}\qquad A\ominus B=\left\{z|(B)_z\cap A^c=\varnothing\right\}</span></li><li>腐蚀的定义形式并不唯一</li></ul></li><li><p>膨胀</p><ul><li><span class='math-in-toc'>A\oplus B=\left\{z|[(\hat B)_z\cap A]\subseteq A\right\}\qquad A\oplus B=\left\{z|(\hat B)_z\cap A\neq\varnothing\right\}</span></li><li>膨胀的定义形式并不唯一</li></ul></li><li><p>对偶性</p><ul><li><span class='math-in-toc'>(A\ominus B)^c=A^c\oplus\hat B\qquad (A\oplus B)^c=A^c\ominus\hat B</span></li><li>在膨胀的定义中之所以有<span class='math-in-toc'>B</span>的反射这一步，是为了在结构元<span class='math-in-toc'>B</span>不关于原点对称的时候腐蚀和膨胀的方向一致</li></ul></li></ul></li><li><p>开操作和闭操作 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>开操作</p><ul><li><span class='math-in-toc'>A\circ B=(A\ominus B)\oplus B</span></li><li>平滑物体的轮廓，断开较窄的细颈并消除细的突出物</li><li><span class='math-in-toc'>A\circ B</span>是<span class='math-in-toc'>A</span>的一个子集；<span class='math-in-toc'>C</span>是<span class='math-in-toc'>D</span>的子集，那么<span class='math-in-toc'>C\circ B</span>是<span class='math-in-toc'>D\circ B</span>的子集；<span class='math-in-toc'>(A\circ B)\circ B=A\circ B</span></li></ul></li><li><p>闭操作</p><ul><li><span class='math-in-toc'>A\bullet B=(A\oplus B)\ominus B</span></li><li>平滑物体的轮廓，弥合较窄的间断和细长的沟壑，消除小的孔洞，填补轮廓线中的断裂</li><li><span class='math-in-toc'>A</span>是<span class='math-in-toc'>A\bullet B</span>一个子集；<span class='math-in-toc'>C</span>是<span class='math-in-toc'>D</span>的子集，那么<span class='math-in-toc'>C\bullet B</span>是<span class='math-in-toc'>D\bullet B</span>的子集；<span class='math-in-toc'>(A\bullet B)\bullet B=A\bullet B</span></li></ul></li><li><p>对偶性</p><ul><li><span class='math-in-toc'>(A\bullet B)^c=(A^c\circ\hat B)\qquad(A\circ B)^c=(A^c\bullet\hat B)</span></li></ul></li></ul></li><li><p>击中或击不中变换 <span class='math-in-toc'>\spadesuit</span></p><ul><li><span class='math-in-toc'>A\circledast B=(A\ominus B_1)\cap (A^c\ominus B_2)\quad B_1=D,B_2=(W-D)</span></li><li>仅当两个或多个物体形成相脱离的集合时，它们才是可分的<span class='math-in-toc'>\Rightarrow</span>通过要求每个物体至少被一个像素宽的背景所环绕（<span class='math-in-toc'>B_2=W-D</span>）</li></ul></li><li><p>基本的形态学算法</p><ul><li><p>边界提取：<span class='math-in-toc'>\beta(A)=A-(A\ominus B)</span></p></li><li><p>孔洞填充：</p><ul><li>初始化<span class='math-in-toc'>X_0</span>---假设已知一个点</li><li><span class='math-in-toc'>X_k=(X_{k-1}\oplus B)\cap A^c</span></li><li>若<span class='math-in-toc'>X_k=X_{k-1}</span>，停止，<span class='math-in-toc'>X_k\cup A</span>为最终结果</li></ul></li><li><p>连通分量提取</p><ul><li>初始化<span class='math-in-toc'>X_0</span>---假设已知一个点</li><li><span class='math-in-toc'>X_k=(X_{k-1}\oplus B)\cap A</span></li><li>若<span class='math-in-toc'>X_k=X_{k-1}</span>，停止，<span class='math-in-toc'>X_k</span>包含输入图像中的所有连通分量</li><li>所用的结构元决定了连通分量是基于8连通还是4连通的</li></ul></li></ul></li></ul></li><li><p><strong>七、图像分割</strong></p><ul><li><p>基础</p><ul><li>不连续性---基于边缘的分割</li><li>相似性---基于区域的分割</li></ul></li><li><p>点、线、边缘检测</p><ul><li><p>基础</p><ul><li>一阶导数产生较粗的边缘</li><li>二阶导数对精细细节，如细线、孤立点和噪声有较强的响应</li><li>二阶导数在灰度斜坡和灰度台阶过渡处会产生双边缘响应</li><li>二阶导数的符号可以确定边缘的过渡是从亮到暗（负）还是从暗到亮（正）</li></ul></li><li><p>孤立点的检测：拉普拉斯算子（空域模板）+ 阈值处理</p></li><li><p>线检测</p><ul><li>拉普拉斯算子（空域模板）---各向同性</li><li>专门模板---特定方向线的检测</li></ul></li><li><p>边缘检测</p><ul><li><p>边缘模型</p><ul><li><p>台阶模型，斜坡模型，屋顶边缘模型</p></li><li><p>零交叉点：定位粗边缘的中心</p></li><li><p>二阶导数对噪声很敏感---平滑处理</p></li><li><p>步骤：</p><ul><li>平滑处理以降噪</li><li>边缘点的检测：从一幅图像中提取所有点作为边缘点的候选者</li><li>边缘定位：从上一步得到的点集合中选出真实的边缘点</li></ul></li></ul></li><li><p>基本边缘检测技术</p><ul><li>梯度算子：Roberts, Sobel, Prewitt（一般形式，检测对角边缘的形式）</li><li>与阈值处理结合</li></ul></li><li><p>更先进的边缘检测技术</p><ul><li><p>Marr-Hildreth</p><ul><li>高斯低通滤波器（空域上卷积）滤波<span>	</span><span class='math-in-toc'>G(x,y)=e^{-\frac{x^2+y^2}{2\sigma^2}}</span></li><li>运用拉普拉斯算子</li><li>找到零交叉（有阈值的零交叉）</li></ul></li><li><p>坎尼边缘检测器 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>目标</p><ul><li>低错误率：所有边缘都应被找到，没有伪响应</li><li>边缘点被很好的定位</li><li>单一的边缘点响应：对于真实的边缘点，仅应返回一个点（边缘很细）</li></ul></li><li><p>步骤</p><ul><li><p>高斯滤波器（空域上卷积）平滑输入图像</p><ul><li>二维高斯可以把被分解为两个一维高斯的乘积，二维卷积就可以分解为两个一维卷积</li></ul></li><li><p>计算梯度幅值图像和角度图像</p><ul><li>利用梯度算子得到<span class='math-in-toc'>g(x,y)</span>，<span class='math-in-toc'>M(x,y)=\sqrt{g_x^2+g_y^2}\quad \alpha(x,y)=arctan(\frac{g_x}{g_y})</span></li></ul></li><li><p>对梯度幅值图像应用最大值抑制</p><ul><li>寻找最接近<span class='math-in-toc'>\alpha(x,y)</span>的方向<span class='math-in-toc'>d_k</span>(事先确定的基本边缘方向)</li><li>如果<span class='math-in-toc'>M(x,y)</span>大于沿<span class='math-in-toc'>d_k</span>的两个的邻居，则保留，否则抑制（取0）</li></ul></li><li><p>用双阈值处理和连接分析来检测并连接边缘</p><ul><li><span class='math-in-toc'>g_{NH}(x,y)\mbox{与}g_{NL}(x,y)</span></li><li>连接分析：以<span class='math-in-toc'>g_{NH}(x,y)</span>为基础，在<span class='math-in-toc'>g_{NL}(x,y)</span>中选择边缘点</li></ul></li></ul></li></ul></li></ul></li><li><p>边缘连接与边界检测</p><ul><li><p>使用霍夫变换的全局处理 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p><span class='math-in-toc'>xy</span>平面到参数空间的变换</p><ul><li><span class='math-in-toc'>x\cos\theta+y\sin\theta=\rho</span></li><li>累加单元：<span class='math-in-toc'>\rho\theta</span>平面上的点<span class='math-in-toc'>A(i,j)</span>的值代表<span class='math-in-toc'>xy</span>平面中位于直线<span class='math-in-toc'>x\cos\theta_j+y\sin\theta_j=\rho_i</span>上的非背景点（二值图像）的个数</li><li>其他的函数变换如圆<span class='math-in-toc'>(x-c_1)^2+(y-c_2)^2=c_3^2</span></li></ul></li><li><p>基于霍夫变换的连接</p><ul><li>得到一幅二值图像</li><li>指定<span class='math-in-toc'>\rho\theta</span>平面中的细分</li><li>检验感兴趣处的累加单元的数量</li><li>若缝隙长度比阈值小，则连接起来</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>全局阈值处理</p><ul><li>初始化全局阈值<span class='math-in-toc'>T</span></li><li>根据<span class='math-in-toc'>T</span>分割该图像得到<span class='math-in-toc'>G_1</span>和<span class='math-in-toc'>G_2</span>两个像素集合</li><li>计算<span class='math-in-toc'>G_1</span>和<span class='math-in-toc'>G_2</span>的平均灰度值<span class='math-in-toc'>m_1</span>和<span class='math-in-toc'>m_2</span></li><li>得到新阈值<span class='math-in-toc'>T=\frac{m_1+m_2}{2}</span></li><li>若更新前后的<span class='math-in-toc'>T</span>的差值小于预定义的参数，停止迭代</li></ul></li><li><p>区域生长</p><ul><li>在<span class='math-in-toc'>S(x,y)</span>中寻找所有连通分量并将之腐蚀成一个像素标记为1（种子点），其他像素标记为0</li><li>形成图像<span class='math-in-toc'>f_Q</span>：若输入图像的像素点满足给定属性<span class='math-in-toc'>Q</span>，标记为1，否则标记为0</li><li>将<span class='math-in-toc'>f_Q</span>中所有8连通种子点的所有1值点添加到<span class='math-in-toc'>S</span>中得到图像<span class='math-in-toc'>g</span></li><li>标记出<span class='math-in-toc'>g</span>中的不同连通分量</li></ul></li></ul></li><li><p><strong>八、表示和描述</strong></p><ul><li><p>表示</p><ul><li><p>边界追踪 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>假设：二值图像（目标为1，背景为0）；已使用0进行边界填充</p></li><li><p>步骤</p><ul><li>以前景区域（为1）左上角的点为<span class='math-in-toc'>b_0</span>，<span class='math-in-toc'>c_0</span>为其左邻点（为0）</li><li>从<span class='math-in-toc'>c</span>开始绕<span class='math-in-toc'>b</span>顺时针寻找到第一个标为1的点记为<span class='math-in-toc'>n_k</span>，之前的一点<span class='math-in-toc'>n_{k-1}</span></li><li><span class='math-in-toc'>t=t+1\quad c_t=n_{k-1}\quad b_t=n_k</span>（存储<span class='math-in-toc'>b_0,b_1</span>的位置）</li><li>若<span class='math-in-toc'>b_t=b_0</span>且<span class='math-in-toc'>b_{t+1}=b_1</span>，停止（防止”毛刺“的干扰）</li></ul></li></ul></li><li><p>链码 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>重取样；编码（4方向链码，8方向链码）</p></li><li><p>边界的链码取决于起始点---归一化</p><ul><li>起始点归一化：选择起始点使得号码序列取得最小值</li><li>旋转归一化（与旋转无关）：使用链码的一次差分（逆时针方向计算间隔，如8链码：0-6=2）</li></ul></li></ul></li></ul></li><li><p>边界描绘子：描绘子应尽可能对平移、旋转和尺度变换不敏感，尽可能对起始点不敏感</p><ul><li><p>一些简单的描绘子</p><ul><li>直径<span class='math-in-toc'>Diam(B)=\max\limits_{i,j}[D(p_i,p_j)]</span></li><li>偏心率：长轴与短轴之比</li><li>曲率</li></ul></li><li><p>形状数 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>定义为最小量级的一次差分</p></li><li><p>由形状数的阶（形状数表示的数字的个数）确定形状数：</p><ul><li>找到基本矩形，划分网格</li><li>得到链码（链码的方向与网格对齐）</li><li>得到一次差分</li><li>得到形状数</li></ul></li></ul></li><li><p>傅里叶描绘子 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>傅里叶描绘子<span class='math-in-toc'>a(u)=\sum_{k=0}^{K-1}s(k)e^{-j2\pi uk/K}</span><span>	</span><span class='math-in-toc'>s(k)=x(k)+jy(k)</span></p></li><li><p>仅使用前<span class='math-in-toc'>P</span>个傅里叶系数<span class='math-in-toc'>a(u)</span>表示边界，相当于低通滤波</p></li><li><p>性质</p><ul><li>恒等 <span class='math-in-toc'>s(k)\Rightarrow a(u)</span></li><li>旋转 <span class='math-in-toc'>s(k)e^{j\theta}\Rightarrow a(u)e^{j\theta}</span></li><li>平移 <span class='math-in-toc'>s(k)+\Delta_{xy}\Rightarrow a(u)+\Delta_{xy}\delta(u)</span></li><li>缩放 <span class='math-in-toc'>\alpha s(k)\Rightarrow \alpha a(u)</span></li><li>起始点 <span class='math-in-toc'>s(k-k_0)\Rightarrow a(u)e^{-j2\pi k_0u/K}</span></li></ul></li></ul></li><li><p>统计矩 <span class='math-in-toc'>\spadesuit</span></p><ul><li><span class='math-in-toc'>\mu_n(v)=\sum_{i=0}^{A-1}(v_i-m)^np(v_i)\qquad m=\sum_{i=0}^{A-1}v_ip(v_i)</span></li><li>矩直接与边界的形状有关，如二阶矩度量曲线关于均值的扩展程度。三阶矩度量曲线关于均值的对称性</li><li>通常仅使用前几个矩就可以区分明显不同形状的信号</li><li>矩对旋转不敏感</li></ul></li></ul></li><li><p>区域描绘子</p><ul><li><p>一些简单的描绘子</p><ul><li>面积+周长<span class='math-in-toc'>\Rightarrow (周长)^2/面积</span>---致密性</li><li>圆度率<span class='math-in-toc'>R_c=\frac{4\pi A}{P^2}\quad A:面积，P:周长</span> ：一个区域的面积与同周长的圆（最致密的形状）的面积之比 <span class='math-in-toc'>\spadesuit</span></li><li>灰度级的均值、中值、最值</li></ul></li><li><p>拓扑描绘子</p><ul><li>孔洞数</li><li>连通分量的数量</li><li><span class='math-in-toc'>欧拉数=连通分量的数量-孔洞数</span> <span class='math-in-toc'>\spadesuit</span></li></ul></li><li><p>纹理：平滑度、粗糙度、规律性等特性的度量</p><ul><li><p>统计方法 <span class='math-in-toc'>\spadesuit</span></p><ul><li><p>只考虑灰度的分布</p><ul><li>二阶矩的变形：<span class='math-in-toc'>R(z)=1-\frac{1}{1+\sigma^2(z)}</span>(方差需要先归一化到[0,1]内)---描述相对平滑度</li><li>三阶矩---直方图偏斜度</li><li>四阶矩---相对平坦度</li><li><span class='math-in-toc'>U(z)=\sum_{i=0}^{L-1}p^2(z_i)</span>---一致性（所有灰度级都相等时最大）</li><li><span class='math-in-toc'>e(z)=-\sum_{i=0}^{L-1}p(z_i)log_2p(z_i)</span>---可变性（所有灰度级都相等时为0）</li></ul></li><li><p>考虑灰度的分布和像素的相对位置</p><ul><li><p><span class='math-in-toc'>f</span>:输入灰度图像；<span class='math-in-toc'>L</span>:最大灰度级数；<span class='math-in-toc'>Q</span>:定义两个像素彼此相对位置的一个算子；<span class='math-in-toc'>G</span>:（灰度级）共生矩阵</p></li><li><p>为了减少计算负担，常将灰度量化为几段</p></li><li><p>表征<span class='math-in-toc'>G</span>的描绘子（<span class='math-in-toc'>p_{ij}=g_{ij}/n</span>）</p><ul><li>最大概率</li><li>相关</li><li>对比度</li><li>一致性</li><li>同质性</li><li>熵</li></ul></li></ul></li></ul></li><li><p>结构方法：图像像元的排列</p></li><li><p>频谱方法：只需考虑半个频谱</p><ul><li>在二维傅里叶频谱图中得到<span class='math-in-toc'>S(r,\theta)</span>，分别固定<span class='math-in-toc'>\theta</span>和<span class='math-in-toc'>r</span>，得到<span class='math-in-toc'>S_\theta(r)</span>和<span class='math-in-toc'>S_r(\theta)</span>，进一步积分得到<span class='math-in-toc'>S(r)=\sum_{\theta=0}^\pi S_\theta(r)\quad S(\theta)=\sum_{r=0}^{R_0}S_r(\theta)</span></li><li>在计算出这些函数本身的描绘子</li></ul></li></ul></li><li><p>不变矩 <span class='math-in-toc'>\spadesuit</span></p><ul><li>二维<span class='math-in-toc'>p+q</span>阶矩<span class='math-in-toc'>m_{pq}=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}x^py^qf(x,y)\quad p,q\geq 0</span></li><li>二维<span class='math-in-toc'>p+q</span>阶中心矩<span class='math-in-toc'>\mu_{pq}=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}(x-\overline x)^p(y-\overline y)^qf(x,y)\qquad \overline x=\frac{m_{10}}{m_{00}},\overline y=\frac{m_{01}}{m_{00}}\quad p,q\geq 0</span></li><li>归一化中心矩<span class='math-in-toc'>\eta_{pq}=\frac{\mu_{pq}}{\mu_{00}^\gamma}\quad \gamma=\frac{p+q}{2}+1\quad p+q\geq 2</span></li><li>二阶矩和三阶矩推出7个不变矩组，对于平移、尺度变换、镜像（<span class='math-in-toc'>\phi_7 会反号</span>）、旋转不变</li></ul></li></ul></li></ul></li></ul></div>
</body>
</html>